1. What is the difference between a functional component and a class component in React?

Answer:
Functional components are plain JavaScript functions that return JSX. 
Class components are ES6 classes that extend React.Component and require a render() method.

Code:
// Functional
const Hello = () => <h1>Hello</h1>;

// Class
class Hello extends React.Component {
  render() {
    return <h1>Hello</h1>;
  }
}
-------------------------------
2. How does the key prop help React in lists?

Answer:
The key prop gives React a way to identify which items have changed, are added, or removed. 
It optimizes rendering performance by avoiding unnecessary re-renders.

Code:
{items.map(item => (
  <li key={item.id}>{item.name}</li>
))}
-------------------------------
3. What is "lifting state up" in React?

Answer:
Lifting state up means moving shared state to the closest common ancestor of components that need it. 
This enables those components to stay in sync.

Code:
// Parent manages state and passes it down
function Parent() {
  const [count, setCount] = useState(0);
  return <Child count={count} setCount={setCount} />;
}
-------------------------------
4. What happens when you call setState or useState's updater?

Answer:
React schedules a re-render of the component with the new state. 
It does not update state immediately; updates are batched and asynchronous.

Code:
setCount(count + 1);
console.log(count); // Still old value immediately after
-------------------------------
5. What is JSX and why do we use it?

Answer:
JSX is a syntax extension that allows writing HTML-like code in JavaScript. 
React uses it to describe UI components declaratively.

Code:
const element = <h1>Hello, JSX!</h1>;
-------------------------------
6. How does useState work, and when should you use functional updates?

Answer:
useState returns [state, setState]. Updates are asynchronous and may be batched. 
Use functional updates (setState(prev => ...)) when the new value depends on the previous 
state to avoid stale reads in batched updates.

Code:
const [count, setCount] = useState(0);

// Bad if multiple calls happen in one tick:
setCount(count + 1);
setCount(count + 1); // might end up +1

// Good: functional updates are safe in batches:
setCount(c => c + 1);
setCount(c => c + 1); // reliably +2
-------------------------------
7. Explain useEffect dependencies, cleanup, and common pitfalls.

Answer:
useEffect runs after render. The dependency array controls when it re-runs:

- No deps: runs after every render.

- []: runs once after mount (and cleanup on unmount).

- [a, b]: runs when a or b changes.

Cleanup: return a function to dispose resources (timers, subscriptions, in-flight requests).

Common pitfalls:

- Missing deps → stale values/bugs. Use ESLint’s react-hooks/exhaustive-deps.

- Stale closures → reference current values or move logic into the effect.

- Race conditions with async work → cancel/ignore outdated results.

Code (fetch with cancellation):
useEffect(() => {
  const ctrl = new AbortController();
  let active = true;

  (async () => {
    try {
      const res = await fetch('/api/data', { signal: ctrl.signal });
      if (!active) return;
      const json = await res.json();
      setData(json);
    } catch (e) {
      if (e.name !== 'AbortError') setError(e);
    }
  })();

  return () => {
    active = false;
    ctrl.abort();
  };
}, [query]);
-------------------------------
8. What’s the difference between useMemo and useCallback? When should you use them?

Answer:
- useMemo(fn, deps) memoizes a computed value.

- useCallback(fn, deps) memoizes a function reference (equivalent to useMemo(() => fn, deps)).

Use them to:

- Avoid expensive recalculations.

- Stabilize object/function identities passed to children (to reduce re-renders with React.memo).

Code:
const expensive = useMemo(() => heavyCompute(input), [input]);
const onSelect = useCallback(id => setSelected(id), []);

// Child re-renders only if relevant props change
const Child = React.memo(({ onSelect, item }) => /* ... */);
-------------------------------
9. What are practical uses of useRef?

Answer:
useRef holds a mutable value that persists across renders without causing re-renders when it changes. Use cases:

- Accessing/controlling DOM nodes.

- Storing instance-like mutable data (timers, previous values, flags).

- Avoiding re-creation of expensive non-UI objects.

Code (focus input + previous value):
const inputRef = useRef(null);
const prevValueRef = useRef();

useEffect(() => {
  prevValueRef.current = value;
}, [value]);

const focus = () => inputRef.current?.focus();

return <input ref={inputRef} value={value} onChange={e => setValue(e.target.value)} />;

***Gotcha: Changing ref.current does not trigger a render.***
-------------------------------
10. When should you use useReducer and how do you factor logic into a custom hook?

Answer:
Use useReducer for complex state with multiple transitions or when you want a single place to manage state logic (predictability, testability).

Wrap related logic in a custom hook to encapsulate state, effects, and actions and reuse across components.

Code (reducer + custom hook):
function counterReducer(state, action) {
  switch (action.type) {
    case 'inc': return { ...state, count: state.count + 1 };
    case 'dec': return { ...state, count: state.count - 1 };
    case 'reset': return { count: 0 };
    default: return state;
  }
}

function useCounter(initial = 0) {
  const [state, dispatch] = useReducer(counterReducer, { count: initial });
  const inc = useCallback(() => dispatch({ type: 'inc' }), []);
  const dec = useCallback(() => dispatch({ type: 'dec' }), []);
  const reset = useCallback(() => dispatch({ type: 'reset' }), []);
  return { count: state.count, inc, dec, reset };
}

*** Rules of Hooks (must know):***
Only call hooks at the top level of a React function.
Only call hooks from React functions (components or custom hooks).
-------------------------------
11. What are the benefits of using Context API and when should you avoid it?

Answer:
The Context API allows data to be shared globally (like theme, auth, language) without prop drilling.

Use it when:
- You need to share state/data across many deeply nested components.
- You have static or low-frequency-updating values.

Avoid when:
- Context updates frequently — as it causes all consumers to re-render, hurting performance.
- You're managing complex or interrelated state (consider Redux/Zustand/Jotai instead).

Code:
const ThemeContext = createContext();
const App = () => (
  <ThemeContext.Provider value="dark">
    <Child />
  </ThemeContext.Provider>
);
-------------------------------
12. What is Redux, and how does it compare to Context API?

Answer:
Redux is a predictable state container for JS apps. It provides a centralized store, 
strict unidirectional data flow, and dev tools for debugging.

Key differences:
Redux------------------------------------Context API
Great for complex, global state----------Best for light/medium state sharing
Has middleware (redux-thunk, saga)-------No built-in middleware
Dev tools, time-travel debugging---------No built-in dev tooling
Boilerplate heavy (but improving)--------Simpler to set up

Use Redux for:
- Large-scale apps
- Cross-feature communication
- Asynchronous logic and debugging
-------------------------------
13. What are some common strategies for organizing large-scale React apps?

Answer:
Organize by feature/domain, not type.

Feature-based structure:
src/
├── features/
│   ├── auth/
│   │   ├── AuthPage.jsx
│   │   ├── authSlice.js
│   │   └── authAPI.js
│   └── dashboard/
│       ├── DashboardPage.jsx
│       └── widgets/
├── components/
├── hooks/
├── utils/
├── store/
└── App.jsx
Other strategies:

- Co-locate styles, tests, and logic near components.
- Use barrel files (index.ts) for clean imports.
- Modularize routes and lazy load per feature.
-------------------------------
14. How do you handle cross-cutting concerns like loading, errors, and authentication globally?

Answer:
Loading/Error: Centralize logic in stores (Redux), or wrap with HOCs/hooks/context.

- Authentication:

-- Store token in memory (or localStorage if needed).

-- Protect routes using a <PrivateRoute> or conditional render in routes.

- Layout composition: Use shared layout components (Header/Footer) with children.

Example - Protected Route:
function PrivateRoute({ children }) {
  const { user } = useAuth();
  return user ? children : <Navigate to="/login" />;
}

-------------------------------
15. What is code splitting and lazy loading in React? Why is it important?

Answer:
Code splitting breaks up your bundle so users only load what they need. React supports this via React.lazy() and Suspense.

Benefits:
- Faster initial load time
- Reduced memory usage
- Better perceived performance

Code:
const LazyPage = React.lazy(() => import('./HeavyPage'));

function App() {
  return (
    <Suspense fallback={<Spinner />}>
      <LazyPage />
    </Suspense>
  );
}
Tip: Combine with route-based code splitting using React Router and lazy().
-------------------------------
16. What are Higher-Order Components (HOCs), and how do they differ from render props?

Answer:
An HOC is a function that takes a component and returns a new component with added behavior or data.

const withLogging = WrappedComponent => {
  return props => {
    console.log('Rendering:', WrappedComponent.name);
    return <WrappedComponent {...props} />;
  };
};
Render props pattern passes a function as a prop that returns UI.
<DataProvider render={data => <Chart data={data} />} />

Key differences:
HOCs wrap components.
Render props use composition via a function.
-------------------------------
17. What is an Error Boundary in React, and when should you use one?

Answer:
Error boundaries catch runtime errors in the component tree during rendering, 
in lifecycle methods, and in constructors of child components.

They:

- Prevent the entire app from crashing

- Show fallback UIs

Code (class only):
class ErrorBoundary extends React.Component {
  state = { hasError: false };
  static getDerivedStateFromError() {
    return { hasError: true };
  }
  componentDidCatch(error, info) {
    logError(error, info);
  }
  render() {
    return this.state.hasError ? <Fallback /> : this.props.children;
  }
}
React 18 doesn’t yet support error boundaries with hooks.
-------------------------------
18. What is React’s concurrent mode and why does it matter?

Answer:
Concurrent Mode (now evolving into Concurrent Features) allows React to interrupt rendering and prioritize tasks for a smoother UI.

It enables:
- startTransition() for low-priority updates
- useDeferredValue() to defer rendering
- Better responsiveness under load

Code:
import { startTransition } from 'react';

const handleSearch = e => {
  const input = e.target.value;
  setInput(input);
  startTransition(() => {
    setQuery(input); // Low-priority update
  });
};
-------------------------------
19. What is React Server Components (RSC)?

Answer:
React Server Components let you render components on the server and stream them to the client. They:

- Never send their JS to the browser
- Can safely access backend resources (DBs, APIs)
- Improve performance by reducing JS bundle size

Used in frameworks like Next.js App Router (.server.js vs .client.js).

Important distinctions:

- RSCs are not interactive
- You compose them with client components
-------------------------------
20. How do you optimize performance in large React applications?

Answer:
Memoization:
- React.memo for component props
- useMemo and useCallback to avoid recalculations/re-creations

Code Splitting: React.lazy, Suspense
Avoid unnecessary re-renders:
- Use key props properly
- Avoid re-creating functions/objects unless needed

Virtualization: react-window, react-virtualized for long lists
Throttle/Debounce: Use lodash.debounce for input handling
Profiling: Use React DevTools Profiler to find bottlenecks
-------------------------------
21. How does React Router work, and what’s the difference between <BrowserRouter> and <HashRouter>?

Answer:
React Router uses the HTML5 history API (or hash in URLs) to keep the UI in sync with the URL.

- <BrowserRouter>: Uses clean URLs (/about). Requires server configuration to serve index.html for all routes.

- <HashRouter>: Uses hash fragments (/#/about). No server config needed, but URLs look less clean.

Code:
<BrowserRouter>
  <Routes>
    <Route path="/" element={<Home />} />
    <Route path="/about" element={<About />} />
  </Routes>
</BrowserRouter>
-------------------------------
22. How do you integrate API calls into a React application?

Answer:
- Use fetch or Axios inside useEffect for GET calls.

- Manage loading and error states.

- Cancel or ignore outdated requests to prevent race conditions.

useEffect(() => {
  let ignore = false;
  async function fetchData() {
    try {
      const res = await fetch('/api/data');
      const json = await res.json();
      if (!ignore) setData(json);
    } catch (e) {
      setError(e);
    }
  }
  fetchData();
  return () => { ignore = true; };
}, [url]);
-------------------------------
23. How do you test React components with React Testing Library?

Answer:
RTL focuses on testing components from a user’s perspective.

Key steps:

1. Render the component with render().
2. Query elements using getByText, getByRole, etc.
3. Fire events with fireEvent or userEvent.
4. Assert expected outcomes.

Code:
import { render, screen, fireEvent } from '@testing-library/react';
import Counter from './Counter';

test('increments counter', () => {
  render(<Counter />);
  fireEvent.click(screen.getByText(/increment/i));
  expect(screen.getByText(/count: 1/i)).toBeInTheDocument();
});
-------------------------------
24. What is Jest, and how does it work with React Testing Library?

Answer:
- Jest is a JavaScript testing framework for running tests, mocking functions/modules, and generating coverage.
- React Testing Library builds on Jest to test React components by simulating user interactions and asserting DOM output.

Jest handles:

- Test running
- Assertions
- Mocks/stubs
- Snapshots
-------------------------------
25. How do you deploy a React app to production?

Answer:
1. Build the app:
npm run build

2. Choose hosting:

- Static hosts: Netlify, Vercel, GitHub Pages

- Traditional server: Apache/Nginx (serve build folder)

3. Upload build output to host.

4. Configure server for SPA:

- Redirect all routes to index.html (except static files).

Example: Netlify _redirects file
/* /index.html 200
-------------------------------
26. React 18 Features & Updates

What are React 18’s main new features?

Answer:
- Concurrent Rendering (via startTransition, useDeferredValue)
- Automatic Batching of state updates across promises/events
- Suspense for Data Fetching with concurrent APIs
- Streaming Server-Side Rendering (SSR)
- useId hook for unique, SSR-safe IDs
- Improved StrictMode behaviors
-------------------------------
27. What is automatic batching and how does it improve performance?

Answer:
In React 18, state updates in the same event loop are batched automatically, even inside promises or async calls.

Before React 18:
fetchData().then(() => {
  setCount(c => c + 1);
  setFlag(true); // caused 2 renders
});
After React 18:
Same code → only 1 render.
-------------------------------
28. How does useId work, and why is it useful?

Answer:
useId generates a unique, stable ID for components, safe for SSR/hydration.

const id = useId();
<label htmlFor={id}>Name</label>
<input id={id} />

Prevents mismatches between server and client-generated IDs.
-------------------------------
29. What’s the difference between startTransition and useDeferredValue?

Answer:
startTransition: Marks a state update as low-priority.

useDeferredValue: Defers using a value until after urgent updates.

startTransition(() => {
  setFilter(input);
});

const deferredFilter = useDeferredValue(input);
-------------------------------
30. How does React 18 improve SSR performance?

Answer:
- Streaming HTML as it’s generated → faster first paint.
- Suspense support on server → send placeholders first, hydrate later.
- Smaller JavaScript payloads when using Server Components.
-------------------------------
31. State Management Beyond Redux
When should you pick a server-state library (React Query/SWR) vs a client-state store (Zustand/Jotai/Context)?

Answer:
Server state (remote, cacheable, shared, stale over time) → React Query/SWR (fetching, caching, revalidation, retries, pagination).

Client state (local UI state, ephemeral selections, toggles) → Zustand/Jotai/Context.
Rule of thumb: Don’t put server state in Redux/Context; keep it in a data-fetching cache layer.
-------------------------------
32. What are the pros/cons of Zustand vs Redux?

Answer:
Zustand: minimal API, plain JS, no providers/selectors ceremony; great ergonomics and performance via slice selectors.

Redux: mature ecosystem, strong devtools/middleware, predictable patterns; more boilerplate.
Use: Zustand for small/medium apps & feature stores; Redux for very large teams or when you need its middleware/devtools conventions.
-------------------------------
33. How do selectors prevent unnecessary re-renders?

Answer:
Selectors subscribe to a slice of state; components re-render only when that slice changes (by reference/equality).

// Zustand example
const count = useStore(s => s.counter.count);

Use shallow compare/memoized selectors to reduce churn.
-------------------------------
34. What is XState and when is a state machine/statechart useful?

Answer:
XState models finite states and transitions (idle → loading → success/error). 
Useful for complex, multi-step, async flows (wizards, payments) and to avoid “boolean soup.”
-------------------------------
35. How do you structure a hybrid approach (React Query + Zustand/Redux) cleanly?

Answer:
- Server data: React Query (queries/mutations, caching).
- UI/client data: Zustand/Redux (filters, panel open, selected IDs).
- Boundary: Never duplicate data between layers; store only IDs/UI flags in client store and derive the rest from the query cache.
-------------------------------
36.
-------------------------------
37.
-------------------------------
38.
-------------------------------
39.
-------------------------------
40.
-------------------------------
41.
-------------------------------
42.
-------------------------------
43.
-------------------------------
44.
-------------------------------
45.
-------------------------------
46.
-------------------------------
47.
-------------------------------
48.
-------------------------------
49.
-------------------------------
50.
-------------------------------
